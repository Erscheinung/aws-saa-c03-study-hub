<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deduction Trainer | AWS SAA-C03</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-card: #1a2332;
            --accent-orange: #ff6b35;
            --accent-blue: #4facfe;
            --accent-green: #00f5a0;
            --accent-red: #ef4444;
            --accent-yellow: #fbbf24;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: #2d3748;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .back-btn {
            padding: 10px 20px;
            border-radius: 30px;
            border: 2px solid var(--accent-blue);
            background: transparent;
            color: var(--accent-blue);
            text-decoration: none;
            transition: all 0.2s;
        }
        
        .back-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }
        
        /* Strategy Cards */
        .strategy-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .strategy-card {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }
        
        .strategy-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .strategy-title {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.95rem;
        }
        
        .strategy-desc {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        /* Progress */
        .progress-bar {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 15px 25px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .progress-fill-container {
            flex: 1;
            height: 10px;
            background: var(--bg-primary);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-orange), var(--accent-green));
            transition: width 0.5s;
        }
        
        .progress-text {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-blue);
        }
        
        /* Question Area */
        .question-area {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .question-number {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-orange);
        }
        
        .difficulty {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .difficulty.easy { background: rgba(0,245,160,0.2); color: var(--accent-green); }
        .difficulty.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
        .difficulty.hard { background: rgba(239,68,68,0.2); color: var(--accent-red); }
        
        .scenario {
            font-size: 1.1rem;
            line-height: 1.8;
            margin-bottom: 25px;
        }
        
        .keyword {
            background: rgba(255,107,53,0.2);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--accent-orange);
            font-weight: 500;
        }
        
        /* Options */
        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .option {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 18px 20px;
            background: var(--bg-primary);
            border-radius: 12px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .option:hover:not(.disabled) {
            border-color: var(--accent-blue);
        }
        
        .option.eliminated {
            opacity: 0.4;
            text-decoration: line-through;
            border-style: dashed;
        }
        
        .option.selected {
            border-color: var(--accent-orange);
            background: rgba(255,107,53,0.1);
        }
        
        .option.correct {
            border-color: var(--accent-green);
            background: rgba(0,245,160,0.1);
        }
        
        .option.wrong {
            border-color: var(--accent-red);
            background: rgba(239,68,68,0.1);
        }
        
        .option.disabled {
            cursor: default;
        }
        
        .option-letter {
            width: 30px;
            height: 30px;
            background: var(--bg-card);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .option-text {
            flex: 1;
        }
        
        .eliminate-btn {
            padding: 5px 12px;
            border-radius: 15px;
            border: 1px solid var(--accent-red);
            background: transparent;
            color: var(--accent-red);
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .option:hover .eliminate-btn {
            opacity: 1;
        }
        
        .option.eliminated .eliminate-btn,
        .option.disabled .eliminate-btn {
            display: none;
        }
        
        /* Action Buttons */
        .actions {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 25px;
        }
        
        .action-btn {
            padding: 12px 25px;
            border-radius: 30px;
            border: 2px solid;
            background: transparent;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-btn.submit {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }
        
        .action-btn.submit:hover {
            background: var(--accent-green);
            color: var(--bg-primary);
        }
        
        .action-btn.hint {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }
        
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Explanation */
        .explanation {
            margin-top: 25px;
            padding: 25px;
            background: rgba(79,172,254,0.1);
            border-radius: 16px;
            border: 1px solid var(--accent-blue);
            display: none;
        }
        
        .explanation.show { display: block; }
        
        .explanation-title {
            color: var(--accent-blue);
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .deduction-step {
            display: flex;
            gap: 12px;
            margin: 12px 0;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 8px;
        }
        
        .step-number {
            width: 24px;
            height: 24px;
            background: var(--accent-orange);
            color: var(--bg-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.8rem;
            flex-shrink: 0;
        }
        
        .step-text {
            flex: 1;
        }
        
        .step-text .eliminate {
            color: var(--accent-red);
            font-weight: 500;
        }
        
        .step-text .keep {
            color: var(--accent-green);
            font-weight: 500;
        }
        
        .next-btn {
            display: block;
            margin-top: 20px;
            padding: 15px 40px;
            border-radius: 30px;
            border: 2px solid var(--accent-orange);
            background: var(--accent-orange);
            color: var(--bg-primary);
            font-family: inherit;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .next-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255,107,53,0.3);
        }
        
        @media (max-width: 600px) {
            .strategy-cards {
                grid-template-columns: 1fr 1fr;
            }
            
            .option {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéØ Deduction Trainer</h1>
            <a href="../index.html" class="back-btn">‚Üê Back to Hub</a>
        </header>
        
        <div class="strategy-cards">
            <div class="strategy-card">
                <div class="strategy-icon">üö´</div>
                <div class="strategy-title">Impossible Specs</div>
                <div class="strategy-desc">Eliminate options with wrong limits or features</div>
            </div>
            <div class="strategy-card">
                <div class="strategy-icon">üéØ</div>
                <div class="strategy-title">Keyword Match</div>
                <div class="strategy-desc">Look for "cost-effective", "least effort", etc.</div>
            </div>
            <div class="strategy-card">
                <div class="strategy-icon">‚ö°</div>
                <div class="strategy-title">Service Fit</div>
                <div class="strategy-desc">Match service capabilities to requirements</div>
            </div>
            <div class="strategy-card">
                <div class="strategy-icon">üîÑ</div>
                <div class="strategy-title">Complexity Check</div>
                <div class="strategy-desc">Overly complex solutions are usually wrong</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill-container">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div class="progress-text" id="progressText">0/0</div>
        </div>
        
        <div class="question-area" id="questionArea">
            <!-- Question loaded dynamically -->
        </div>
    </div>
    
    <script>
        const questions = [
            {
                difficulty: 'easy',
                scenario: 'A company needs to run <span class="keyword">batch processing</span> jobs that can be <span class="keyword">interrupted</span>. They want the <span class="keyword">most cost-effective</span> EC2 solution.',
                options: [
                    { letter: 'A', text: 'On-Demand Instances', eliminate: true, reason: 'On-Demand is full price - not cost-effective for interruptible workloads' },
                    { letter: 'B', text: 'Reserved Instances (1-year)', eliminate: true, reason: 'Reserved requires commitment and is for steady-state, not batch' },
                    { letter: 'C', text: 'Spot Instances', correct: true, reason: 'Spot is up to 90% cheaper and perfect for interruptible batch jobs' },
                    { letter: 'D', text: 'Dedicated Hosts', eliminate: true, reason: 'Dedicated Hosts are the most expensive option - compliance use case' }
                ],
                deduction: [
                    { step: 'Keywords: "batch processing", "interrupted", "cost-effective"' },
                    { step: '<span class="eliminate">Eliminate D</span>: Dedicated Hosts = expensive, no cost benefit' },
                    { step: '<span class="eliminate">Eliminate A</span>: On-Demand = full price, not "cost-effective"' },
                    { step: '<span class="eliminate">Eliminate B</span>: Reserved = commitment, not flexible for batch' },
                    { step: '<span class="keep">Keep C</span>: Spot Instances = up to 90% off, designed for interruptible workloads' }
                ]
            },
            {
                difficulty: 'medium',
                scenario: 'A web application needs to store session data with <span class="keyword">sub-millisecond latency</span>. The data should be <span class="keyword">highly available</span> and support <span class="keyword">automatic failover</span>.',
                options: [
                    { letter: 'A', text: 'DynamoDB with DAX', eliminate: false, reason: 'DAX provides microsecond latency but is DynamoDB-specific' },
                    { letter: 'B', text: 'ElastiCache for Redis with Multi-AZ', correct: true, reason: 'Redis provides sub-ms latency, Multi-AZ gives HA with auto-failover' },
                    { letter: 'C', text: 'RDS MySQL with Read Replicas', eliminate: true, reason: 'RDS has millisecond latency, not sub-millisecond' },
                    { letter: 'D', text: 'S3 with Transfer Acceleration', eliminate: true, reason: 'S3 is object storage, not designed for session data or sub-ms latency' }
                ],
                deduction: [
                    { step: 'Keywords: "sub-millisecond", "highly available", "automatic failover"' },
                    { step: '<span class="eliminate">Eliminate D</span>: S3 is object storage, wrong use case for sessions' },
                    { step: '<span class="eliminate">Eliminate C</span>: RDS has ms latency, not sub-ms; no auto-failover for reads' },
                    { step: 'Compare A vs B: Both have sub-ms latency' },
                    { step: '<span class="keep">Choose B</span>: Redis Multi-AZ has built-in auto-failover; sessions are key-value perfect fit' }
                ]
            },
            {
                difficulty: 'medium',
                scenario: 'A company needs to securely connect their on-premises data center to AWS VPC. They require <span class="keyword">consistent network performance</span> and <span class="keyword">bypass the public internet</span>.',
                options: [
                    { letter: 'A', text: 'AWS Site-to-Site VPN', eliminate: true, reason: 'VPN uses public internet, performance varies' },
                    { letter: 'B', text: 'AWS Direct Connect', correct: true, reason: 'Dedicated connection bypasses internet with consistent performance' },
                    { letter: 'C', text: 'VPC Peering', eliminate: true, reason: 'VPC Peering is between VPCs, not on-premises' },
                    { letter: 'D', text: 'AWS Transit Gateway', eliminate: true, reason: 'Transit Gateway is for VPC connectivity, still needs underlying connection' }
                ],
                deduction: [
                    { step: 'Keywords: "consistent performance", "bypass public internet"' },
                    { step: '<span class="eliminate">Eliminate C</span>: VPC Peering is VPC-to-VPC, not on-prem' },
                    { step: '<span class="eliminate">Eliminate D</span>: Transit Gateway needs Direct Connect or VPN underneath' },
                    { step: '<span class="eliminate">Eliminate A</span>: VPN uses public internet = inconsistent performance' },
                    { step: '<span class="keep">Keep B</span>: Direct Connect is dedicated, bypasses internet, consistent' }
                ]
            },
            {
                difficulty: 'hard',
                scenario: 'A serverless application uses Lambda functions triggered by API Gateway. The function needs to process requests that may take up to <span class="keyword">5 minutes</span>. Users should receive a response <span class="keyword">immediately</span>.',
                options: [
                    { letter: 'A', text: 'Increase Lambda timeout to 5 minutes and wait for completion', eliminate: true, reason: 'API Gateway has 29-second timeout - cannot wait 5 minutes' },
                    { letter: 'B', text: 'Use Lambda with SQS - return immediately, process async', correct: true, reason: 'Async pattern: return acknowledgment immediately, process in background' },
                    { letter: 'C', text: 'Use Step Functions with synchronous execution', eliminate: true, reason: 'Synchronous still blocked by API Gateway 29-second limit' },
                    { letter: 'D', text: 'Use API Gateway with 5-minute timeout', eliminate: true, reason: 'API Gateway max timeout is 29 seconds - impossible configuration' }
                ],
                deduction: [
                    { step: 'Keywords: "5 minutes processing", "respond immediately" - contradiction needs async' },
                    { step: '<span class="eliminate">Eliminate D</span>: API Gateway max is 29 seconds - this is IMPOSSIBLE' },
                    { step: '<span class="eliminate">Eliminate A</span>: Lambda 15-min limit OK, but API Gateway still blocks at 29s' },
                    { step: '<span class="eliminate">Eliminate C</span>: Synchronous Step Functions still bound by API Gateway timeout' },
                    { step: '<span class="keep">Keep B</span>: Async pattern - immediately return, SQS queues work for Lambda' }
                ]
            },
            {
                difficulty: 'easy',
                scenario: 'An application stores files up to <span class="keyword">10 GB</span> in size. The storage solution must be <span class="keyword">cost-effective</span> and support <span class="keyword">infrequent access</span>.',
                options: [
                    { letter: 'A', text: 'S3 Standard', eliminate: true, reason: 'Standard is for frequent access - more expensive' },
                    { letter: 'B', text: 'S3 Standard-IA', correct: true, reason: 'Infrequent Access tier is designed for this exact use case' },
                    { letter: 'C', text: 'EBS gp3 volumes', eliminate: true, reason: 'EBS is block storage attached to EC2, not for file storage' },
                    { letter: 'D', text: 'DynamoDB', eliminate: true, reason: 'DynamoDB has 400KB item limit - cannot store 10GB files' }
                ],
                deduction: [
                    { step: 'Keywords: "10 GB files", "infrequent access", "cost-effective"' },
                    { step: '<span class="eliminate">Eliminate D</span>: DynamoDB 400KB limit - IMPOSSIBLE for 10GB files' },
                    { step: '<span class="eliminate">Eliminate C</span>: EBS is block storage, wrong service category' },
                    { step: '<span class="eliminate">Eliminate A</span>: Standard is for frequent access - not cost-effective here' },
                    { step: '<span class="keep">Keep B</span>: S3-IA is literally named for this use case' }
                ]
            },
            {
                difficulty: 'hard',
                scenario: 'A global application requires <span class="keyword">single-digit millisecond</span> read latency across multiple regions. Data must be <span class="keyword">strongly consistent</span> for writes. Which database solution is most appropriate?',
                options: [
                    { letter: 'A', text: 'DynamoDB Global Tables', eliminate: true, reason: 'Global Tables use eventual consistency for cross-region replication' },
                    { letter: 'B', text: 'Aurora Global Database', correct: true, reason: 'Aurora Global provides <1s replication and local reads with write forwarding' },
                    { letter: 'C', text: 'ElastiCache Global Datastore', eliminate: true, reason: 'ElastiCache is caching, not primary database with strong consistency' },
                    { letter: 'D', text: 'RDS with Cross-Region Read Replicas', eliminate: true, reason: 'Read replicas are async/eventually consistent, not strongly consistent' }
                ],
                deduction: [
                    { step: 'Keywords: "single-digit ms", "multiple regions", "strongly consistent writes"' },
                    { step: '<span class="eliminate">Eliminate C</span>: ElastiCache is caching layer, not source of truth DB' },
                    { step: '<span class="eliminate">Eliminate D</span>: RDS read replicas are async = eventual consistency' },
                    { step: '<span class="eliminate">Eliminate A</span>: DynamoDB Global Tables cross-region = eventual consistency' },
                    { step: '<span class="keep">Keep B</span>: Aurora Global has write forwarding for consistency, low-latency reads' }
                ]
            },
            {
                difficulty: 'medium',
                scenario: 'A company needs to protect their web application from <span class="keyword">SQL injection</span> and <span class="keyword">cross-site scripting (XSS)</span> attacks. The solution should be <span class="keyword">managed</span> with <span class="keyword">minimal operational overhead</span>.',
                options: [
                    { letter: 'A', text: 'AWS Shield Standard', eliminate: true, reason: 'Shield is for DDoS, not application-layer attacks like SQLi' },
                    { letter: 'B', text: 'AWS WAF with managed rules', correct: true, reason: 'WAF provides SQLi and XSS protection with AWS-managed rule sets' },
                    { letter: 'C', text: 'Security Groups with strict rules', eliminate: true, reason: 'Security Groups are L3/L4 (IP/port), cannot inspect HTTP content' },
                    { letter: 'D', text: 'Custom Lambda@Edge validation', eliminate: true, reason: 'Custom code = high operational overhead, opposite of requirement' }
                ],
                deduction: [
                    { step: 'Keywords: "SQL injection", "XSS", "managed", "minimal overhead"' },
                    { step: '<span class="eliminate">Eliminate C</span>: Security Groups are IP/port level, cannot detect SQLi' },
                    { step: '<span class="eliminate">Eliminate A</span>: Shield is DDoS protection, not app-layer attacks' },
                    { step: '<span class="eliminate">Eliminate D</span>: Custom Lambda = high operational overhead' },
                    { step: '<span class="keep">Keep B</span>: WAF with managed rules = built-in SQLi/XSS, AWS maintains it' }
                ]
            },
            {
                difficulty: 'easy',
                scenario: 'A company wants to encrypt data at rest in S3. They need to <span class="keyword">manage their own encryption keys</span> but don\'t want to handle the <span class="keyword">encryption process</span>.',
                options: [
                    { letter: 'A', text: 'SSE-S3', eliminate: true, reason: 'SSE-S3 uses Amazon-managed keys, not customer-managed' },
                    { letter: 'B', text: 'SSE-KMS with customer managed key (CMK)', correct: true, reason: 'Customer manages key in KMS, S3 handles encryption' },
                    { letter: 'C', text: 'SSE-C (Customer Provided Keys)', eliminate: true, reason: 'SSE-C requires customer to provide key with each request = more work' },
                    { letter: 'D', text: 'Client-side encryption', eliminate: true, reason: 'Client-side = customer handles entire encryption process' }
                ],
                deduction: [
                    { step: 'Keywords: "manage own keys" BUT "don\'t handle encryption process"' },
                    { step: '<span class="eliminate">Eliminate A</span>: SSE-S3 = Amazon manages keys, not customer' },
                    { step: '<span class="eliminate">Eliminate D</span>: Client-side = customer does encryption (contradicts requirement)' },
                    { step: '<span class="eliminate">Eliminate C</span>: SSE-C requires providing key each time = more operational work' },
                    { step: '<span class="keep">Keep B</span>: SSE-KMS CMK = you manage key in KMS, S3 does encryption automatically' }
                ]
            },
            {
                difficulty: 'medium',
                scenario: 'An application needs to store files that will be accessed <span class="keyword">once or twice per month</span>. The company wants to <span class="keyword">minimize storage costs</span> but needs <span class="keyword">quick retrieval</span> when accessed.',
                options: [
                    { letter: 'A', text: 'S3 Standard', eliminate: true, reason: 'Standard is for frequently accessed data - higher cost for this use case' },
                    { letter: 'B', text: 'S3 Standard-IA', correct: true, reason: 'Designed for infrequent access, lower storage cost, millisecond retrieval' },
                    { letter: 'C', text: 'S3 Glacier Instant Retrieval', eliminate: true, reason: 'Good option but more expensive than Standard-IA for monthly access' },
                    { letter: 'D', text: 'S3 Glacier Deep Archive', eliminate: true, reason: '12-48 hour retrieval time - not quick' }
                ],
                deduction: [
                    { step: 'Keywords: "once or twice per month", "minimize costs", "quick retrieval"' },
                    { step: '<span class="eliminate">Eliminate D</span>: Deep Archive = 12-48 hours, NOT quick' },
                    { step: '<span class="eliminate">Eliminate A</span>: Standard = frequent access pricing, not cost-optimized here' },
                    { step: 'Compare B vs C: Both have quick retrieval' },
                    { step: '<span class="keep">Keep B</span>: Standard-IA is cheaper than Glacier Instant for this access pattern' }
                ]
            },
            {
                difficulty: 'hard',
                scenario: 'A company is migrating their on-premises message queue to AWS. The application uses <span class="keyword">JMS and AMQP protocols</span> and must <span class="keyword">minimize code changes</span>.',
                options: [
                    { letter: 'A', text: 'Amazon SQS', eliminate: true, reason: 'SQS uses AWS SDK, not JMS/AMQP - would require code changes' },
                    { letter: 'B', text: 'Amazon SNS', eliminate: true, reason: 'SNS is pub/sub for notifications, not a message queue' },
                    { letter: 'C', text: 'Amazon MQ', correct: true, reason: 'Managed ActiveMQ/RabbitMQ supporting JMS and AMQP protocols' },
                    { letter: 'D', text: 'Amazon Kinesis', eliminate: true, reason: 'Kinesis is for streaming data, not traditional message queuing' }
                ],
                deduction: [
                    { step: 'Keywords: "JMS and AMQP protocols", "minimize code changes"' },
                    { step: '<span class="eliminate">Eliminate D</span>: Kinesis = streaming service, different protocol entirely' },
                    { step: '<span class="eliminate">Eliminate B</span>: SNS = pub/sub notifications, not message queue' },
                    { step: '<span class="eliminate">Eliminate A</span>: SQS = proprietary AWS SDK, requires code changes' },
                    { step: '<span class="keep">Keep C</span>: Amazon MQ = ActiveMQ/RabbitMQ, native JMS/AMQP support' }
                ]
            },
            {
                difficulty: 'easy',
                scenario: 'A startup needs a <span class="keyword">simple, serverless</span> way to host a static website with <span class="keyword">global low latency</span>.',
                options: [
                    { letter: 'A', text: 'EC2 instances behind ALB', eliminate: true, reason: 'EC2 requires server management - not serverless' },
                    { letter: 'B', text: 'S3 static hosting with CloudFront', correct: true, reason: 'Serverless, S3 for hosting, CloudFront for global edge caching' },
                    { letter: 'C', text: 'Elastic Beanstalk', eliminate: true, reason: 'Beanstalk provisions EC2 - overhead for simple static site' },
                    { letter: 'D', text: 'AWS Fargate', eliminate: true, reason: 'Fargate is for containers - overkill for static website' }
                ],
                deduction: [
                    { step: 'Keywords: "simple, serverless", "static website", "global low latency"' },
                    { step: '<span class="eliminate">Eliminate A</span>: EC2 = servers to manage, not serverless' },
                    { step: '<span class="eliminate">Eliminate C</span>: Beanstalk = provisions infrastructure, overkill' },
                    { step: '<span class="eliminate">Eliminate D</span>: Fargate = containers, not needed for static files' },
                    { step: '<span class="keep">Keep B</span>: S3 + CloudFront = serverless, global CDN, simple' }
                ]
            },
            {
                difficulty: 'medium',
                scenario: 'A company needs to analyze <span class="keyword">petabytes of data</span> stored in S3 using <span class="keyword">standard SQL queries</span>. They want to <span class="keyword">pay only when queries run</span>.',
                options: [
                    { letter: 'A', text: 'Amazon Redshift', eliminate: true, reason: 'Redshift requires provisioned clusters - ongoing costs even when not querying' },
                    { letter: 'B', text: 'Amazon EMR', eliminate: true, reason: 'EMR requires cluster management and runs Spark/Hadoop, not pure SQL' },
                    { letter: 'C', text: 'Amazon Athena', correct: true, reason: 'Serverless SQL queries on S3, pay per TB scanned, no infrastructure' },
                    { letter: 'D', text: 'Amazon RDS', eliminate: true, reason: 'RDS is for transactional databases, not S3 analytics' }
                ],
                deduction: [
                    { step: 'Keywords: "petabytes in S3", "SQL queries", "pay when queries run"' },
                    { step: '<span class="eliminate">Eliminate D</span>: RDS = transactional DB, cannot query S3 directly' },
                    { step: '<span class="eliminate">Eliminate B</span>: EMR = Spark/Hadoop, cluster management required' },
                    { step: '<span class="eliminate">Eliminate A</span>: Redshift = provisioned, costs even when idle' },
                    { step: '<span class="keep">Keep C</span>: Athena = serverless SQL on S3, pay $5/TB scanned' }
                ]
            },
            {
                difficulty: 'hard',
                scenario: 'A healthcare application stores patient records in DynamoDB. The company needs to <span class="keyword">encrypt data with keys they fully control</span> for <span class="keyword">HIPAA compliance</span>. They need <span class="keyword">dedicated hardware</span> for key storage.',
                options: [
                    { letter: 'A', text: 'DynamoDB encryption with AWS managed key', eliminate: true, reason: 'AWS-managed keys dont provide customer control' },
                    { letter: 'B', text: 'DynamoDB encryption with KMS CMK', eliminate: true, reason: 'KMS CMK is controlled by customer but runs on shared AWS hardware' },
                    { letter: 'C', text: 'Client-side encryption with CloudHSM', correct: true, reason: 'CloudHSM provides dedicated FIPS 140-2 Level 3 hardware, full key control' },
                    { letter: 'D', text: 'Client-side encryption with Secrets Manager', eliminate: true, reason: 'Secrets Manager stores secrets, not designed for encryption key management' }
                ],
                deduction: [
                    { step: 'Keywords: "fully control keys", "HIPAA", "dedicated hardware"' },
                    { step: '<span class="eliminate">Eliminate A</span>: AWS-managed = no customer control' },
                    { step: '<span class="eliminate">Eliminate D</span>: Secrets Manager = stores secrets, not encryption HSM' },
                    { step: '<span class="eliminate">Eliminate B</span>: KMS = shared infrastructure, not dedicated hardware' },
                    { step: '<span class="keep">Keep C</span>: CloudHSM = dedicated hardware, FIPS 140-2 Level 3, full control' }
                ]
            },
            {
                difficulty: 'medium',
                scenario: 'A company wants to <span class="keyword">automatically rotate</span> their RDS database credentials. The credentials should be <span class="keyword">automatically updated</span> in applications without downtime.',
                options: [
                    { letter: 'A', text: 'AWS Systems Manager Parameter Store', eliminate: true, reason: 'Parameter Store does not support automatic rotation' },
                    { letter: 'B', text: 'AWS Secrets Manager', correct: true, reason: 'Built-in automatic rotation with Lambda, native RDS integration' },
                    { letter: 'C', text: 'AWS IAM database authentication', eliminate: true, reason: 'IAM auth uses tokens, not credential rotation' },
                    { letter: 'D', text: 'Store credentials in S3', eliminate: true, reason: 'S3 is storage, no rotation or secret management features' }
                ],
                deduction: [
                    { step: 'Keywords: "automatically rotate", "RDS credentials", "no downtime"' },
                    { step: '<span class="eliminate">Eliminate D</span>: S3 = just storage, no secret management' },
                    { step: '<span class="eliminate">Eliminate C</span>: IAM auth = different auth method, not rotation' },
                    { step: '<span class="eliminate">Eliminate A</span>: Parameter Store = no automatic rotation' },
                    { step: '<span class="keep">Keep B</span>: Secrets Manager = auto-rotation, RDS integration' }
                ]
            },
            {
                difficulty: 'easy',
                scenario: 'An e-commerce application needs to cache <span class="keyword">user session data</span> with <span class="keyword">sub-millisecond latency</span>. The cache must support <span class="keyword">data persistence</span> and <span class="keyword">replication</span>.',
                options: [
                    { letter: 'A', text: 'ElastiCache for Memcached', eliminate: true, reason: 'Memcached does not support persistence or replication' },
                    { letter: 'B', text: 'ElastiCache for Redis', correct: true, reason: 'Redis supports persistence, replication, and sub-ms latency' },
                    { letter: 'C', text: 'DynamoDB with DAX', eliminate: true, reason: 'DAX is for DynamoDB caching, not general session caching' },
                    { letter: 'D', text: 'RDS with read replicas', eliminate: true, reason: 'RDS has millisecond latency, not sub-millisecond' }
                ],
                deduction: [
                    { step: 'Keywords: "session data", "sub-millisecond", "persistence", "replication"' },
                    { step: '<span class="eliminate">Eliminate D</span>: RDS = milliseconds, not sub-millisecond' },
                    { step: '<span class="eliminate">Eliminate C</span>: DAX = DynamoDB specific, not general caching' },
                    { step: '<span class="eliminate">Eliminate A</span>: Memcached = no persistence, no replication' },
                    { step: '<span class="keep">Keep B</span>: Redis = sub-ms latency + persistence + replication' }
                ]
            },
            {
                difficulty: 'hard',
                scenario: 'A financial services company needs <span class="keyword">single-digit millisecond read latency</span> for a database across <span class="keyword">multiple AWS regions</span>. All writes must be <span class="keyword">strongly consistent</span> and go through the primary region.',
                options: [
                    { letter: 'A', text: 'DynamoDB Global Tables', eliminate: true, reason: 'Global Tables have eventual consistency across regions' },
                    { letter: 'B', text: 'Aurora Global Database with write forwarding', correct: true, reason: 'Local reads with write forwarding to primary ensures consistency' },
                    { letter: 'C', text: 'RDS Multi-AZ with cross-region read replicas', eliminate: true, reason: 'Cross-region replicas are async, eventual consistency' },
                    { letter: 'D', text: 'ElastiCache Global Datastore', eliminate: true, reason: 'ElastiCache is for caching, not primary database' }
                ],
                deduction: [
                    { step: 'Keywords: "single-digit ms", "multiple regions", "strongly consistent writes"' },
                    { step: '<span class="eliminate">Eliminate D</span>: ElastiCache = caching layer, not source of truth' },
                    { step: '<span class="eliminate">Eliminate C</span>: RDS cross-region = async replication, eventual' },
                    { step: '<span class="eliminate">Eliminate A</span>: DynamoDB Global = eventual consistency cross-region' },
                    { step: '<span class="keep">Keep B</span>: Aurora Global + write forwarding = consistent writes, fast local reads' }
                ]
            },
            {
                difficulty: 'medium',
                scenario: 'A company wants to block <span class="keyword">specific IP addresses</span> from accessing their VPC resources. The solution must be at the <span class="keyword">subnet level</span>.',
                options: [
                    { letter: 'A', text: 'Security Groups with deny rules', eliminate: true, reason: 'Security Groups cannot have deny rules - only allow rules' },
                    { letter: 'B', text: 'Network ACLs with deny rules', correct: true, reason: 'NACLs support both allow and deny rules at subnet level' },
                    { letter: 'C', text: 'AWS WAF', eliminate: true, reason: 'WAF works at application layer (Layer 7), not subnet level' },
                    { letter: 'D', text: 'Route table modifications', eliminate: true, reason: 'Route tables control traffic destination, not IP blocking' }
                ],
                deduction: [
                    { step: 'Keywords: "block specific IPs", "subnet level"' },
                    { step: '<span class="eliminate">Eliminate D</span>: Route tables = routing, not blocking' },
                    { step: '<span class="eliminate">Eliminate C</span>: WAF = Layer 7, not subnet level' },
                    { step: '<span class="eliminate">Eliminate A</span>: Security Groups = ONLY allow rules, no deny' },
                    { step: '<span class="keep">Keep B</span>: NACLs = subnet level, support deny rules' }
                ]
            }
        ];
        
        let currentIndex = 0;
        let eliminated = new Set();
        let selected = null;
        let answered = false;
        
        function loadQuestion() {
            const q = questions[currentIndex];
            eliminated = new Set();
            selected = null;
            answered = false;
            
            const area = document.getElementById('questionArea');
            
            area.innerHTML = `
                <div class="question-header">
                    <span class="question-number">Question ${currentIndex + 1} of ${questions.length}</span>
                    <span class="difficulty ${q.difficulty}">${q.difficulty.toUpperCase()}</span>
                </div>
                <div class="scenario">${q.scenario}</div>
                <div class="options" id="optionsContainer">
                    ${q.options.map((opt, i) => `
                        <div class="option" data-index="${i}" onclick="selectOption(${i})">
                            <div class="option-letter">${opt.letter}</div>
                            <div class="option-text">${opt.text}</div>
                            <button class="eliminate-btn" onclick="eliminateOption(event, ${i})">‚úï Eliminate</button>
                        </div>
                    `).join('')}
                </div>
                <div class="actions">
                    <button class="action-btn submit" id="submitBtn" onclick="submitAnswer()" disabled>Submit Answer</button>
                    <button class="action-btn hint" onclick="showHint()">üí° Show Hint</button>
                </div>
                <div class="explanation" id="explanation"></div>
            `;
            
            updateProgress();
        }
        
        function updateProgress() {
            const percent = (currentIndex / questions.length) * 100;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = `${currentIndex}/${questions.length}`;
        }
        
        function selectOption(index) {
            if (answered || eliminated.has(index)) return;
            
            const options = document.querySelectorAll('.option');
            options.forEach((opt, i) => {
                opt.classList.remove('selected');
            });
            
            options[index].classList.add('selected');
            selected = index;
            document.getElementById('submitBtn').disabled = false;
        }
        
        function eliminateOption(event, index) {
            event.stopPropagation();
            if (answered) return;
            
            const option = document.querySelectorAll('.option')[index];
            option.classList.add('eliminated');
            eliminated.add(index);
            
            if (selected === index) {
                selected = null;
                option.classList.remove('selected');
                document.getElementById('submitBtn').disabled = true;
            }
        }
        
        function showHint() {
            const q = questions[currentIndex];
            const wrongOptions = q.options.filter((opt, i) => opt.eliminate && !eliminated.has(i));
            
            if (wrongOptions.length > 0) {
                const randomWrong = wrongOptions[Math.floor(Math.random() * wrongOptions.length)];
                const index = q.options.indexOf(randomWrong);
                eliminateOption({ stopPropagation: () => {} }, index);
            } else {
                alert('No more hints available!');
            }
        }
        
        function submitAnswer() {
            if (selected === null || answered) return;
            answered = true;
            
            const q = questions[currentIndex];
            const options = document.querySelectorAll('.option');
            
            options.forEach((opt, i) => {
                opt.classList.add('disabled');
                if (q.options[i].correct) {
                    opt.classList.add('correct');
                } else if (i === selected && !q.options[i].correct) {
                    opt.classList.add('wrong');
                }
            });
            
            const explanation = document.getElementById('explanation');
            const isCorrect = q.options[selected].correct;
            
            explanation.innerHTML = `
                <div class="explanation-title">${isCorrect ? '‚úì Correct!' : '‚úó Incorrect'} ‚Äî Deduction Process:</div>
                ${q.deduction.map((d, i) => `
                    <div class="deduction-step">
                        <div class="step-number">${i + 1}</div>
                        <div class="step-text">${d.step}</div>
                    </div>
                `).join('')}
                <button class="next-btn" onclick="nextQuestion()">
                    ${currentIndex < questions.length - 1 ? 'Next Question ‚Üí' : 'Finish üéâ'}
                </button>
            `;
            explanation.classList.add('show');
            
            document.getElementById('submitBtn').disabled = true;
        }
        
        function nextQuestion() {
            currentIndex++;
            if (currentIndex >= questions.length) {
                showComplete();
            } else {
                loadQuestion();
            }
        }
        
        function showComplete() {
            const area = document.getElementById('questionArea');
            area.innerHTML = `
                <div style="text-align: center; padding: 50px;">
                    <div style="font-size: 4rem; margin-bottom: 20px;">üéØ</div>
                    <h2 style="font-size: 2rem; margin-bottom: 15px;">Training Complete!</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 30px;">
                        You've practiced the deduction strategies. Remember:<br><br>
                        1Ô∏è‚É£ Look for impossible specs (wrong limits, wrong service)<br>
                        2Ô∏è‚É£ Match keywords to service capabilities<br>
                        3Ô∏è‚É£ Overly complex = usually wrong<br>
                        4Ô∏è‚É£ Trust your elimination process
                    </p>
                    <button class="next-btn" onclick="location.reload()">Practice Again</button>
                </div>
            `;
            document.getElementById('progressFill').style.width = '100%';
            document.getElementById('progressText').textContent = `${questions.length}/${questions.length}`;
        }
        
        // Initialize
        loadQuestion();
    </script>
</body>
</html>
